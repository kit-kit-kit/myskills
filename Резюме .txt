
Воротинцев Иван Алексеевич


Должность:  студент 4го (последнего курса) Хабаровского Института Инфокоммуникаций, специальности ПКС (программироание в компьютерных сетях),
            образование при окончинии среднее-специальное техник-программист 

Опыт работы:    работал 2.5 месяца в Web сфере по созданию и правки сайтов
чем занимался:  мелкие правки, перенос части контента с одной страницы на другую, создание расширяемого текста при нажатии на него,
                адаптация сайтов под мобильные устройства (телефон, планшет), работы с wp, работа с Git


Чем занимаюсь:  изучаю английский язык, изучаю работу в Blender, пишу свою игру на Unreal Engine 5 (UE5) (в ходе разроботки участвуют блюпринты и по мере изучения с++, сам с++)
                изучаю с++, изучаю git, работаю в UE5 с виртуальной реальностью (создание проектов для VR устройств),

Языки программирования которые изучал: html, css, js, немного python, писал свою игру на с#.

Хотелось бы попасть к вам в компанию как стажёр, для преобритения опыта, навыков и принятие качест настоящего специалиста своего дела.




Примеры моих работ:

https://www.codewars.com/users/kit-kit-kit
//сайт на котором я решал каты (задачи) на языке js

//Условия задачи, её примеры и моё решение

/*
Даётся начало и конец года или только начало
и в диапозоне годов программа должна найти все 13-е числа пятницы

Пример:
fridayTheThirteenths(1999, 2000) 
  // returns "8/13/1999 10/13/2000"
  
fridayTheThirteenths(2014, 2015) 
  // returns "6/13/2014 2/13/2015 3/13/2015 11/13/2015"
  
fridayTheThirteenths(2000)
  // returns "10/13/2000"
*/
function fridayTheThirteenths(start, end) {
  moment = require( 'moment' );
  moment.locale('USA');
  let arrYears = []
  let date13
  let arr = []
  // проверка на начало и конец
  if(typeof end === 'number'){ 
    for (let i = start; i <= end; i ++) {
      arrYears.push(i)
    }
  }
  else{
    for (let i = start; i <= start; i ++) {
      arrYears.push(i)
    }
  }
// цикл который перебирает все значения массива(года) 
  for(let j = 0; j < arrYears.length; j++){
    let year = arrYears[j]
    for(let mount = 0; mount < 12; mount++){
      let d13 = new Date(year, mount, 13);
      if (d13.getDay() == 5) {
          arr.push(moment(d13).format( 'M/DD/YYYY'))
      }
    }
  }
  console.log(arr.join(' '))
  return(arr.join(' '))
}
//=====================================================================================================
//=====================================================================================================


/*
поиск уникального числа в массиве
find_uniq(std::vector<float>{1, 1, 1, 2, 1, 1});  // --> 2
find_uniq(std::vector<float>{0, 0, 0.55, 0, 0});  // --> 0.55
*/
function findUniq(arr) {
  for (var i in arr){
     if (arr.indexOf(arr[i]) === arr.lastIndexOf(arr[i])){
       return arr[i]
     }
  }
}
//=====================================================================================================
//=====================================================================================================


/*
поиск уникального числа в массиве
Входные данные: [ 1, 8, 4, 4, 6, 1, 8 ]
Ожидаемый результат: 6
*/
function findUnique(numbers) {
    return numbers.reduce((x, y) => x ^ y);
}
//=====================================================================================================
//=====================================================================================================


/*
------- ------- -------
|     | | ABC | | DEF |
|  1  | |  2  | |  3  |
------- ------- -------
------- ------- -------
| GHI | | JKL | | MNO |
|  4  | |  5  | |  6  |
------- ------- -------
------- ------- -------
|PQRS | | TUV | | WXYZ|
|  7  | |  8  | |  9  |
------- ------- -------
------- ------- -------
|     | |space| |     |
|  *  | |  0  | |  #  |
------- ------- -------

Например, чтобы ввести букву"R", вы должны нажать 7клавишу три раза (по мере циклического отображения текущего символа на экранеP->Q->R->S->7).
*/

function presses(phrase) {
  var num = {'1':1,'A':1,'D':1,'G':1,'J':1,'M':1,'P':1,'T':1,'W':1,' ':1,'*':1,'#':1,'B':2,'E':2,'H':2,'K':2,'N':2,'Q':2,'U':2,'X':2,'0':2,'C':3,'F':3,'I':3,'L':3,'O':3,'R':3,'V':3,'Y':3,'2':4,'3':4,'4':4,'5':4,'6':4,'S':4,'8':4,'Z':4,'7':5,'9':5};
  phrase =  phrase.toUpperCase()
  let NP = phrase.split('')
  return NP.reduce((acc, item) => num[item] + acc, 0);
}
//=====================================================================================================
//=====================================================================================================


/*
Примеры:
Ввод: 42145Вывод: 54421

Ввод: 145263Вывод: 654321

Ввод: 123456789Вывод: 987654321
*/

function descendingOrder(n){
  n = Array.from(String(n), Number)
  n.sort(function(a, b){
  return (b - a)
  })
  return Number(n.join(''))
}
//=====================================================================================================
//=====================================================================================================



/*
Сумма чисел от 0 до N
Пример:

Входные данные:
> 6
Выходной сигнал: 0+1+2+3+4+5+6 = 21

Входные данные:
> -15
Выходной сигнал: -15<0

Входные данные:
> 0
Выходной сигнал: 0=0
*/

var SequenceSum = (function() {
  function SequenceSum() {}

  SequenceSum.showSequence = function(count) {
    if(count == 0){
      return '0=0'
    } else if(count < 0){
      return count+'<0'
    }
    
    let str = ''
    var sum = (count * (count+1)) / 2
    for(let i = 0; i < count+1; i++){
      if(i < count){
        str =str + JSON.parse(i) + '+'
      } else {return str =str + JSON.parse(i) + ' = ' + sum}
    }
  };

  return SequenceSum;

})();
//=====================================================================================================
//=====================================================================================================



/*
Банкоматы допускают 4 или 6 значных PIN-кодов, а PIN-коды не могут содержать ничего, кроме ровно 4 цифр или ровно 6 цифр.

Если функции передана допустимая строка PIN-кода, вернитеtrue, иначе верните false.

Примеры (ввод -> Вывод)
"1234"   -->  true
"12345"  -->  false
"a234"   -->  false
*/

function validatePIN (pin) {
  let arr = pin.split("")
  return (pin.match(/\D/) == null && (arr.length == 4 || arr.length == 6)) ? true : false ;
}
//=====================================================================================================
//=====================================================================================================



/*
Вот несколько примеров того, что должна делать ваша функция:

Ввод														Вывод
["i", "am", "an", "AI"]										"I am an AI."
["FIELDS","of","CORN","are","to","be","sown"]				"FIELDS of CORN are to be sown."
["i'm","afraid","I","can't","let","you","do","that"]		"I'm afraid I can't let you do that."
*/

function sentencify(words) {
  words = words.join(' ');
  words = words.charAt(0).toUpperCase() + words.slice(1)
  return words+'.'
}
//=====================================================================================================
//=====================================================================================================




/*
Примеры
[1, 1, 2] ==> 2
[17, 17, 3, 17, 17, 17, 17] ==> 3
*/

function stray(numbers) {
  var t =  numbers.reduce(function(map,el){
        map[el] = (map[el]||0)+1;
        return map;
    },{});

    var filtered = Object.keys(t).filter(function(el){
      return t[el] == 1;
    })
    
  return parseInt(filtered)
}
//=====================================================================================================
//=====================================================================================================



/*
Дезоксирибонуклеиновая кислота (ДНК) - это химическое вещество, содержащееся в ядре клеток и несущее "инструкции" для развития и функционирования живых организмов.
В строках ДНК символы "A" и "T" дополняют друг друга, как "C" и "G". Ваша функция получает одну сторону ДНК (строку, за исключением Haskell); вам нужно вернуть другую комплементарную сторону. Цепочка ДНК никогда не бывает пустой или ДНК вообще нет (опять же, за исключением Haskell).

Пример: (ввод -> вывод)
"ATTGC" --> "TAACG"
"GTAT" --> "CATA"
*/

function DNAStrand(dna){
  dna = dna.replace(/T/g, '1');
  dna = dna.replace(/A/g, '2');
  dna = dna.replace(/G/g, '3');
  dna = dna.replace(/C/g, '4');
  
  dna = dna.replace(/2/g, 'T');
  dna = dna.replace(/1/g, 'A');
  dna = dna.replace(/4/g, 'G');
  dna = dna.replace(/3/g, 'C');

  console.log(dna);
  return dna
}
//=====================================================================================================
//=====================================================================================================


+
/*
Задача
Учитывая массив целых чисел, удалите наименьшее значение. Не изменяйте исходный массив / список.Если имеется несколько элементов с одинаковым значением, удалите тот, у которого индекс меньше. Если вы получаете пустой массив / список, верните пустой массив / список.

Не меняйте порядок оставшихся элементов.

Примеры
* Input: [1,2,3,4,5], output = [2,3,4,5]
* Input: [5,3,2,1,4], output = [5,3,2,4]
* Input: [2,2,1,2,1], output = [2,2,2,1]
*/

function removeSmallest(numbers) {
  const min_arr = Math.min(...numbers);
  const index = numbers.indexOf(min_arr);
  return numbers.filter((_, i) => i !== index)
}
//=====================================================================================================
//=====================================================================================================



/*
Задача
Напишите функцию, которая возвращает как минимальное, так и максимальное число данного списка / массива.

Примеры (Ввод -> Вывод)
[1,2,3,4,5] --> [1,5]
[2334454,5] --> [5,2334454]
[1]         --> [1,1]
*/

function minMax(arr){
  var max = Math.max.apply(undefined,arr);
  var min = Math.min.apply(undefined,arr);
  arr = []
  arr[0] = min;
  arr[1] = max;
  return arr
}
//=====================================================================================================
//=====================================================================================================



/*
Заданное число возвращает ближайшее к нему число, которое делится на 10.

Пример ввода:

22
25
37
Ожидаемый результат:

20
30
40
*/

const closestMultiple10 = num => {
  return Math.round(num / 10) * 10;
};
//=====================================================================================================
//=====================================================================================================



/*
Возвращает количество (количество) гласных в заданной строке.
Мы будем рассматривать a, e, i, o, uкак гласные для этого ката (но неy).
Строка ввода будет состоять только из строчных букв и / или пробелов.
*/

function getCount(str) {
  //I wanted to compare through the key, but it still didn't work out :(
  var vowelsCount = 0;
  var s = str.split("");
  s = s.filter(val => val == 'a')
  vowelsCount += s.length
  s = str.split("");
  s = s.filter(val => val == 'e')
  vowelsCount += s.length
  s = str.split("");
  s = s.filter(val => val == 'i')
  vowelsCount += s.length
  s = str.split("");
  s = s.filter(val => val == 'o')
  vowelsCount += s.length
  s = str.split("");
  s = s.filter(val => val == 'u') 
  vowelsCount += s.length
  console.log(s)
  return vowelsCount;
}
//=====================================================================================================
//=====================================================================================================



/*
Изограмма - это слово, в котором нет повторяющихся букв, последовательных или непоследовательных. Реализуйте функцию, которая определяет, является ли строка, содержащая только буквы, изограммой. Предположим, что пустая строка является изограммой. Игнорировать регистр букв.
Пример: (Ввод -> Вывод)
"Дерматоглифы" -> истинное "aba" -> ложное "moOse" -> ложное (игнорировать регистр букв)

isIsogram "Dermatoglyphics" = true
isIsogram "moose" = false
isIsogram "aba" = false
*/

function isIsogram(str){
  str = str.toLowerCase().toString().split('');
  let arr = (new Set(str)).size !== str.length;
  if(arr == false){return true}else{return false}
}
//=====================================================================================================
//=====================================================================================================



/*
Ножницы режут бумагу
Бумага покрывает камень
Камень давит ящерицу
Ящерица отравляет Спока
Спок разбивает ножницы
Ножницы обезглавливают ящерицу
Ящерица ест бумагу
Бумага опровергает Спока
Спок испаряет камень
Камень сокрушает ножницы
Задание:
Учитывая два значения из приведенной выше игры, верните результат игрока как "Player 1 Won!", "Player 2 Won!", или "Draw!".
*/

function rpsls(pl1,pl2){
  let rules = {
    scissors:['paper','lizard'],
    paper:['rock','spock'],
    rock:['lizard','scissors'],
    lizard:['spock','paper'],
    spock:['scissors','rock']
  }
  if (pl1 == pl2) {
       return "Draw!";
    }
  if (rules[pl1].includes(pl2))
        return 'Player 1 Won!'
    else
        return 'Player 2 Won!'

}
//=====================================================================================================
//=====================================================================================================



/*
камень ножницы бумага
*/

const rps = (p1, p2) => {
  var rules = {
        'paper'    : 'rock',
        'rock'     : 'scissors',
        'scissors' : 'paper'
    };
    if (p1 == p2) {
       return "Draw!";
    } else{
        return rules[p1] == p2 ? "Player 1 won!" : "Player 2 won!" ;
    }
};
//=====================================================================================================
//=====================================================================================================



/*
Панграмма - это предложение, которое содержит каждую отдельную букву алфавита по крайней мере один раз. Например, предложение "Быстрая бурая лиса перепрыгивает через ленивую собаку" является панграммой, потому что в нем используются буквы A-Z по крайней мере один раз (регистр не имеет значения).

Получив строку, определите, является ли она панграммой или нет. Верните True, если это так, False, если нет. Не обращайте внимания на цифры и знаки препинания.
*/

function isPangram(string){
  let lowerCased = string.toLowerCase(); // из заглавных букв в маленькие
   for(let char of 'abcdefghijklmnopqrstuvwxyz'){
      if(!lowerCased.includes(char)){ //если какой-то буквы не будет то идёт проверка
         return false
       }
    }
  return true
}
//=====================================================================================================
//=====================================================================================================



/*
Если мы перечислим все натуральные числа ниже 10, которые кратны 3 или 5, мы получим 3, 5, 6 и 9. Сумма этих кратных равна 23.

Завершите решение так, чтобы оно возвращало сумму всех кратных 3 или 5 ниже переданного числа. Кроме того, если число отрицательное, верните 0 (для языков, в которых они есть).

Примечание: Если число кратно как 3, так и 5, считайте его только один раз.
*/

function solution(number){
  let w = 0 ,i = 0, b = 0;
  while (i < number){
    b = --number ;
    if(number%3 == 0 || number%5 == 0){
        w += b;
      }
  }
  return w;
}
//=====================================================================================================
//=====================================================================================================



/*
В этом ката вас попросят возвести в квадрат каждую цифру числа и объединить их.
Например, если мы запустим 9119 через функцию, получится 811181, потому что 9 2 равно 81, а 1 2 равно 1. (81-1-1-81)
Пример # 2: Ввод 765 вернет / должен вернуть 493625, потому что 7 2 равно 49, 6 2 равно 36, а 5 2 равно 25. (49-36-35)
Примечание: Функция принимает целое число и возвращает целое число.
*/

function squareDigits(num){
  arrnum = [],
  sNum = num.toString();
  for (var i = 0, len = sNum.length; i < len; i += 1)
  {
      arrnum.push(+sNum.charAt(i));
  }
  arrnum = arrnum.map(x => x * x)
  let str = arrnum.join('');
  return Number(str)
}
//=====================================================================================================
//=====================================================================================================



/*
В этом ката вы создадите функцию, которая принимает список неотрицательных целых чисел и строк и возвращает новый список с отфильтрованными строками.

Пример
filter_list([1,2,'a','b']) == [1,2]
filter_list([1,'a','b',0,15]) == [1,0,15]
filter_list([1,2,'aasf','1','123',123]) == [1,2,123]
*/

function filter_list(l) {
  return l.filter(number => typeof number == 'number' && number >= 0);
}
//=====================================================================================================
//=====================================================================================================



/*
Создайте программу, которая фильтрует список строк и возвращает список, содержащий только имя вашего друга.
Если в имени ровно 4 буквы, вы можете быть уверены, что это должен быть ваш друг! В противном случае, вы можете быть уверены, что это не так...
Пример: Ввод = ["Райан", "Киран", "Джейсон", "Ты"], Вывод = ["Райан", "Ты"]

то есть

friend ["Ryan", "Kieran", "Mark"] `shouldBe` ["Ryan", "Mark"]
Примечание: сохраните первоначальный порядок имен в выходных данных.
*/

function friend(friends){
  let Myfriends = friends.filter(friends => friends.length == 4)
  return Myfriends  
}


